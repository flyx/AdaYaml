with Ada.Strings.UTF_Encoding;
with Ada.Finalization;
with System.Storage_Elements;

package Yada.Strings is
   pragma Preelaborate;
   --  this package defines a reference-counted string pointer type called
   --  Content. it is used for all YAML data entities and relieves the user from
   --  the need to manually dispose events created by the parser.
   --  typically, YAML content strings are deallocated in the same order as they
   --  are allocated. this knowledge is built into a storage pool for efficient
   --  memory usage and to avoid fragmentation.
   --
   --  HINT: this package makes use of compiler implementation details and may
   --  not work with other compilers. however, since there currently are no
   --  Ada 2012 compilers but GNAT, this is not considered a problem.

   --  the pool allocates the memory it uses on the heap. it is allowed for the
   --  pool to vanish while Content strings created on it are still around. the
   --  heap memory is reclaimed when the pool itself and all Content strings
   --  created by it vanish.
   --
   --  this type has pointer semantics in order to allow the usage of the same
   --  pool at different places without the need of access types. copying a
   --  value of this type will make both values use the same memory. use Create
   --  to generate a new independent pool.
   type String_Pool is new Ada.Finalization.Controlled with private;

   --  must be called once before the string pool can be used. if called again,
   --  the string pool re-initializes itself with new memory, and the old memory
   --  lives on only in Content strings that have already been generated. the
   --  old memory is reclaimed once all string references to it vanish.
   procedure Create (Pool : in out String_Pool;
                     Initial_Size : System.Storage_Elements.Storage_Count);

   --  all strings generated by Yada are encoded in UTF-8, regardless of input
   --  encoding.
   subtype UTF_8_String is Ada.Strings.UTF_Encoding.UTF_8_String;
   type UTF_8_String_Access is access UTF_8_String;

   --  this type is used to forbid the user to copy the pointer to UTF_8_String
   --  into a variable of a named access type. thus, we can be sure that no
   --  pointer to the String outlives the smart pointers.
   type Accessor (Data : not null access constant UTF_8_String) is
     limited private with Implicit_Dereference => Data;

   --  this is a smart pointer with pointer semantics. use Value to access its
   --  content.
   type Content is private;

   function Value (Object : Content) return Accessor with Inline;
   function "=" (Left, Right : Content) return Boolean with Inline;

   --  create a new string from the given data. the string will be allocated
   --  within the pool.
   function From_String (Pool : in out String_Pool'Class; Data : String)
                         return Content;

   Null_Content : constant Content;
private
   --  this forces GNAT to store the First and Last dope values right before
   --  the first element of the String. we use that to our advantage.
   for UTF_8_String_Access'Size use Standard'Address_Size;

   --  the pool consists of multiple chunks of memory. strings are allocated
   --  inside the chunks.
   type Chunk is access System.Storage_Elements.Storage_Array;
   type Chunk_Index_Type is range 1 .. 10;
   type Chunk_Array is array (Chunk_Index_Type) of Chunk;
   type Usage_Array is array (Chunk_Index_Type) of Natural;
   subtype Refcount_Type is Integer range 0 .. 2 ** 24 - 1;

   --  the idea is that Cur is the pointer to the active Chunk. all new strings
   --  are allocated in that active Chunk until there is no more space. then,
   --  we allocate a new Chunk of twice the size of the current one and make
   --  that the current Chunk. the old Chunk lives on until all Content strings
   --  allocated on it vanish. Usage is the number of strings currently
   --  allocated on the Chunk and is used as reference count. the current Chunk
   --  has Usage + 1 which prevents its deallocation even if the last Content
   --  string on it vanishes. the Content type's finalization takes care of
   --  decrementing the Usage value that counts allocated strings, while the
   --  String_Pool type's deallocation takes care of removing the +1 for the
   --  current Chunk.
   --
   --  we treat each Chunk basically as a bitvector ring list, and Pos is the
   --  current offset in the current Chunk. instead of having a full bitvector
   --  for allocating, we use the dope values from the strings that stay in the
   --  memory after deallocation. besides the First and Last values, we also
   --  store a reference count in the dope. so when searching for a place to
   --  allocate a new string, we can skip over regions that have a non-zero
   --  reference count in their header, and those with a 0 reference count are
   --  available space. compared to a real bitvector, we always have the
   --  information of the length of an free region available. we can avoid
   --  fragmentation by merging a region that is freed with the surrounding free
   --  regions.
   type Pool_Data is record
      Refcount : Refcount_Type := 1;
      Chunks : Chunk_Array;
      Usage  : Usage_Array := (1 => 1, others => 0);
      Cur    : Chunk_Index_Type := 1;
      Pos    : System.Storage_Elements.Storage_Offset;
   end record;

   type Pool_Data_Access is access Pool_Data;
   for Pool_Data_Access'Size use Standard'Address_Size;

   type String_Pool is new Ada.Finalization.Controlled with record
      Data : Pool_Data_Access;
   end record;

   overriding procedure Adjust (Object : in out String_Pool);
   overriding procedure Finalize (Object : in out String_Pool);

   type Accessor (Data : not null access constant UTF_8_String) is limited
      record
         --  holds a copy of the smart pointer, so the string cannot be freed
         --  while the accessor lives.
         Hold : Content;
      end record;

   type Content is new Ada.Finalization.Controlled with record
      Data : UTF_8_String_Access;
   end record;

   overriding procedure Adjust (Object : in out Content);
   overriding procedure Finalize (Object : in out Content);

   --  for debugging
   function Current_Chunk_As_String (Pool : String_Pool) return String;

   Null_Content : constant Content :=
     (Ada.Finalization.Controlled with Data => null);

end Yada.Strings;
