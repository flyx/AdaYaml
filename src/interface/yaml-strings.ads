with Ada.Strings.UTF_Encoding;
with Ada.Finalization;
with System.Storage_Elements;
private with Ada.Unchecked_Conversion;

package Yaml.Strings is
   --  this package defines a reference-counted string pointer type called
   --  Content. it is used for all YAML data entities and relieves the user from
   --  the need to manually dispose events created by the parser.
   --  typically, YAML content strings are deallocated in the same order as they
   --  are allocated. this knowledge is built into a storage pool for efficient
   --  memory usage and to avoid fragmentation.
   --
   --  HINT: this package makes use of compiler implementation details and may
   --  not work with other compilers. however, since there currently are no
   --  Ada 2012 compilers but GNAT, this is not considered a problem.

   --  the pool allocates the memory it uses on the heap. it is allowed for the
   --  pool to vanish while Content strings created on it are still around. the
   --  heap memory is reclaimed when the pool itself and all Content strings
   --  created by it vanish.
   --
   --  this type has pointer semantics in order to allow the usage of the same
   --  pool at different places without the need of access types. copying a
   --  value of this type will make both values use the same memory. use Create
   --  to generate a new independent pool.
   type String_Pool is new Ada.Finalization.Controlled with private;
   subtype Pool_Offset is System.Storage_Elements.Storage_Offset
     range 0 .. System.Storage_Elements.Storage_Offset (Integer'Last);

   --  must be called once before the string pool can be used. if called again,
   --  the string pool re-initializes itself with new memory, and the old memory
   --  lives on only in Content strings that have already been generated. the
   --  old memory is reclaimed once all string references to it vanish.
   procedure Create (Pool : in out String_Pool;
                     Initial_Size : Pool_Offset);

   --  all strings generated by Yaml are encoded in UTF-8, regardless of input
   --  encoding.
   subtype UTF_8_String is Ada.Strings.UTF_Encoding.UTF_8_String;
   type UTF_8_String_Access is access UTF_8_String;

   --  this type is used to forbid the user to copy the pointer to UTF_8_String
   --  into a variable of a named access type. thus, we can be sure that no
   --  pointer to the String outlives the smart pointers.
   type Accessor (Data : not null access constant UTF_8_String) is
     limited private with Implicit_Dereference => Data;

   --  this is a smart pointer with pointer semantics. use Value to access its
   --  content.
   type Content is private;

   function Value (Object : Content) return Accessor with Inline;
   function "=" (Left, Right : Content) return Boolean with Inline;

   --  create a new string from the given data. the string will be allocated
   --  within the pool.
   function From_String (Pool : in out String_Pool'Class; Data : String)
                         return Content;

   Null_Content : constant Content;

   type Constant_Content_Holder (<>) is private;

   function Hold (Value : String) return Constant_Content_Holder
     with Pre => (Value'Length <= 128);
   function Held (Holder : Constant_Content_Holder) return Content;

   subtype Exported_String is System.Address;

   function Export (Object : Content) return Exported_String;
   procedure Delete_Exported (Exported : Exported_String);
private
   --  this forces GNAT to store the First and Last dope values right before
   --  the first element of the String. we use that to our advantage.
   for UTF_8_String_Access'Size use Standard'Address_Size;

   --  the pool consists of multiple chunks of memory. strings are allocated
   --  inside the chunks.
   type Pool_Array is array (Pool_Offset range <>) of System.Storage_Elements.Storage_Element;
   type Chunk is access Pool_Array;
   type Chunk_Index_Type is range 1 .. 10;
   type Chunk_Array is array (Chunk_Index_Type) of Chunk;
   type Usage_Array is array (Chunk_Index_Type) of Natural;
   subtype Refcount_Type is Integer range 0 .. 2 ** 24 - 1;

   --  the idea is that Cur is the pointer to the active Chunk. all new strings
   --  are allocated in that active Chunk until there is no more space. then,
   --  we allocate a new Chunk of twice the size of the current one and make
   --  that the current Chunk. the old Chunk lives on until all Content strings
   --  allocated on it vanish. Usage is the number of strings currently
   --  allocated on the Chunk and is used as reference count. the current Chunk
   --  has Usage + 1 which prevents its deallocation even if the last Content
   --  string on it vanishes. the Content type's finalization takes care of
   --  decrementing the Usage value that counts allocated strings, while the
   --  String_Pool type's deallocation takes care of removing the +1 for the
   --  current Chunk.
   --
   --  we treat each Chunk basically as a bitvector ring list, and Pos is the
   --  current offset in the current Chunk. instead of having a full bitvector
   --  for allocating, we use the dope values from the strings that stay in the
   --  memory after deallocation. besides the First and Last values, we also
   --  store a reference count in the dope. so when searching for a place to
   --  allocate a new string, we can skip over regions that have a non-zero
   --  reference count in their header, and those with a 0 reference count are
   --  available space. compared to a real bitvector, we always have the
   --  information of the length of an free region available. we can avoid
   --  fragmentation by merging a region that is freed with the surrounding free
   --  regions.
   type Pool_Data is record
      Refcount : Refcount_Type := 1;
      Chunks : Chunk_Array;
      Usage  : Usage_Array := (1 => 1, others => 0);
      Cur    : Chunk_Index_Type := 1;
      Pos    : Pool_Offset;
   end record;

   type Pool_Data_Access is access Pool_Data;
   for Pool_Data_Access'Size use Standard'Address_Size;

   --  this is the dope vector of each string allocated in a Chunk. it is put
   --  immediately before the string's value. note that the First and Last
   --  elements are at the exact positions where GNAT searches for the string's
   --  boundary dope. this allows us to access those values for maintaining the
   --  ring list.
   type Header is record
      Pool : Pool_Data_Access;
      Chunk_Index : Chunk_Index_Type;
      Refcount : Refcount_Type := 1;
      First, Last : Pool_Offset;
   end record;

   Chunk_Index_Start : constant := Standard'Address_Size;
   Refcount_Start    : constant := Standard'Address_Size + 8;
   First_Start       : constant := Standard'Address_Size + 32;
   Last_Start        : constant := First_Start + Integer'Size;
   Header_End        : constant := Last_Start + Integer'Size - 1;

   for Header use record
      Pool        at 0 range 0 .. Chunk_Index_Start - 1;
      Chunk_Index at 0 range Chunk_Index_Start .. Refcount_Start - 1;
      Refcount    at 0 range Refcount_Start .. First_Start - 1;
      First       at 0 range First_Start .. Last_Start - 1;
      Last        at 0 range Last_Start .. Header_End;
   end record;
   for Header'Size use Header_End + 1;

   use type System.Storage_Elements.Storage_Offset;

   Header_Size : constant Pool_Offset := Header'Size / System.Storage_Unit;

   type Constant_Content_Holder is record
      H : Header;
      S : aliased String (1 .. 128);
   end record;
   for Constant_Content_Holder use record
      H at 0 range 0 .. Header_End;
      S at 0 range Header_End + 1 .. Header_End + 128 * System.Storage_Unit;
   end record;

   function Hold (Value : String) return Constant_Content_Holder is
     ((H => (Pool => null, First => 1, Last => Value'Length, others => <>),
       S => Value & (Value'Length + 1 .. 128 => <>)));

   Null_Content_Holder : constant Constant_Content_Holder := Hold ("");

   type String_Pool is new Ada.Finalization.Controlled with record
      Data : Pool_Data_Access;
   end record with Type_Invariant => String_Pool.Data.Pos mod Header_Size = 1;

   overriding procedure Adjust (Object : in out String_Pool);
   overriding procedure Finalize (Object : in out String_Pool);

   type Accessor (Data : not null access constant UTF_8_String) is limited
      record
         --  holds a copy of the smart pointer, so the string cannot be freed
         --  while the accessor lives.
         Hold : Content;
      end record;

   function To_UTF_8_String_Access is new Ada.Unchecked_Conversion
     (System.Address, UTF_8_String_Access);

   type Content is new Ada.Finalization.Controlled with record
      Data : UTF_8_String_Access :=
        To_UTF_8_String_Access (Null_Content_Holder.S'Address);
   end record;

   overriding procedure Adjust (Object : in out Content);
   overriding procedure Finalize (Object : in out Content);

   --  for debugging
   function Current_Chunk_As_String (Pool : String_Pool) return String;

   Null_Content : constant Content :=
     (Ada.Finalization.Controlled with Data => <>);

end Yaml.Strings;
